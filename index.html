<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‰ç¿å®è§€ Team Building é…å°å°å¹«æ‰‹</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .person-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 60px; /* Min width for consistency */
            height: 60px;
            padding: 0 10px; /* Horizontal padding for longer names */
            border-radius: 30px; /* Pill shape */
            font-weight: bold;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .pair-connector {
            font-size: 1.5em;
            margin: 0 0.5em;
            color: #666;
        }
        details summary {
            cursor: pointer;
            font-weight: bold;
            padding: 0.5rem;
            background-color: #f0f0f0;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
        }
        details summary:hover {
            background-color: #e0e0e0;
        }
        details[open] summary {
            background-color: #d0d0d0;
        }
        .name-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
            transition: color 0.3s, opacity 0.3s;
        }
        .name-item.absent {
            color: #9ca3af; /* Tailwind gray-400 */
            opacity: 0.7;
        }
        .name-item.absent .name-text {
            text-decoration: line-through;
        }
        .name-item:last-child {
            border-bottom: none;
        }
        /* Ensure buttons are consistently sized and styled */
        button {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, opacity 0.2s;
        }
        button:active {
            transform: scale(0.98);
        }
        .action-buttons button {
            margin-left: 0.5rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-100 to-sky-100 min-h-screen flex flex-col items-center justify-center p-4 selection:bg-sky-300 selection:text-sky-900">

    <div class="container mx-auto bg-white shadow-2xl rounded-xl p-6 md:p-8 w-full max-w-4xl">
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-sky-700">å®‰ç¿å®è§€ Team Building é…å°å°å¹«æ‰‹ ğŸ¤</h1>
            <p class="text-slate-600 mt-2">è¼•é¬†æ–°å¢åå–®ï¼Œéš¨æ©Ÿé…å°ï¼Œè¿½è¹¤æ­·å²ç´€éŒ„ï¼</p>
        </header>

        <div class="grid md:grid-cols-2 gap-8">
            <div class="panel-left bg-slate-50 p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold text-slate-800 mb-6 border-b-2 border-sky-500 pb-2">ğŸ§‘â€ğŸ¤â€ğŸ§‘ äººåç®¡ç†</h2>
                
                <div class="space-y-4 mb-6">
                    <div>
                        <label for="singleNameInput" class="block text-sm font-medium text-slate-700 mb-1">æ–°å¢å–®ä¸€äººåï¼š</label>
                        <div class="flex space-x-2">
                            <input type="text" id="singleNameInput" placeholder="ä¾‹å¦‚ï¼šå°å®‰" class="flex-grow p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition duration-150">
                            <button id="addSingleNameBtn" class="bg-sky-500 hover:bg-sky-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50">æ–°å¢</button>
                        </div>
                    </div>
                    <div>
                        <label for="batchNameInput" class="block text-sm font-medium text-slate-700 mb-1">æ‰¹æ¬¡æ–°å¢äººå (æ¯è¡Œä¸€å€‹)ï¼š</label>
                        <textarea id="batchNameInput" placeholder="å°å®‰&#10;å°è¯&#10;å°ç¾" rows="3" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition duration-150"></textarea>
                        <button id="addBatchNameBtn" class="mt-2 w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-sky-600 focus:ring-opacity-50">æ‰¹æ¬¡æ–°å¢</button>
                    </div>
                </div>

                <h3 class="text-xl font-medium text-slate-700 mb-3">ç›®å‰äººåæ¸…å–® (<span id="nameCount" class="font-bold text-sky-600">0</span>äºº):</h3>
                <div id="namesDisplayListContainer" class="bg-white p-4 rounded-lg shadow-inner max-h-60 overflow-y-auto border border-slate-200">
                    <ul id="namesDisplayList" class="space-y-2">
                        </ul>
                    <p id="emptyNameListMessage" class="text-slate-500 text-center py-4">å°šæœªæ–°å¢ä»»ä½•äººåã€‚</p>
                </div>
            </div>

            <div class="panel-right bg-slate-50 p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold text-slate-800 mb-6 border-b-2 border-teal-500 pb-2">ğŸ² é…å°çµæœ</h2>
                
                <div class="controls grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                    <button id="startPairingBtn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-50 text-lg">ğŸš€ é–‹å§‹é…å°</button>
                    <button id="resetRecordsBtn" class="w-full bg-amber-500 hover:bg-amber-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-amber-500 focus:ring-opacity-50">ğŸ”„ é‡ç½®ç´€éŒ„</button>
                </div>

                <div id="currentPairingResult" class="mb-6 min-h-[150px] bg-white p-4 rounded-lg shadow-inner border border-slate-200">
                    <h3 class="text-xl font-medium text-slate-700 mb-1">æœ¬æ¬¡é…å°çµæœ</h3>
                    <p class="text-sm text-slate-500 mb-3">æ—¥æœŸï¼š<span id="pairingDate" class="font-semibold">---</span></p>
                    <div id="pairsContainer" class="space-y-3 text-center">
                        <p id="noPairingMessage" class="text-slate-500 pt-8">é»æ“Šã€Œé–‹å§‹é…å°ã€ä¾†æŸ¥çœ‹çµæœï¼</p>
                        </div>
                </div>

                <div id="pairingHistorySection">
                    <details class="bg-white rounded-lg shadow-inner border border-slate-200">
                        <summary class="text-lg text-slate-700 p-4 hover:bg-slate-100 rounded-t-lg">ğŸ“œ æŸ¥çœ‹æ­·å²é…å°ç´€éŒ„</summary>
                        <div class="p-4 border-t border-slate-200 max-h-72 overflow-y-auto">
                            <ul id="historyList" class="space-y-4">
                                <p id="noHistoryMessage" class="text-slate-500 text-center py-4">ç›®å‰æ²’æœ‰æ­·å²ç´€éŒ„ã€‚</p>
                            </ul>
                        </div>
                    </details>
                </div>
            </div>
        </div>
        <p id="messageArea" class="mt-6 text-center text-sm font-medium h-5"></p>
    </div>

    <script>
        // DOM Elements
        const singleNameInput = document.getElementById('singleNameInput');
        const addSingleNameBtn = document.getElementById('addSingleNameBtn');
        const batchNameInput = document.getElementById('batchNameInput');
        const addBatchNameBtn = document.getElementById('addBatchNameBtn');
        const namesDisplayList = document.getElementById('namesDisplayList');
        const nameCount = document.getElementById('nameCount');
        const emptyNameListMessage = document.getElementById('emptyNameListMessage');
        
        const startPairingBtn = document.getElementById('startPairingBtn');
        const resetRecordsBtn = document.getElementById('resetRecordsBtn');
        
        const pairingDate = document.getElementById('pairingDate');
        const pairsContainer = document.getElementById('pairsContainer');
        const noPairingMessage = document.getElementById('noPairingMessage');
        
        const historyList = document.getElementById('historyList');
        const noHistoryMessage = document.getElementById('noHistoryMessage');
        const messageArea = document.getElementById('messageArea');

        // Global state
        // namesList now stores objects: { id: string, name: string, present: boolean }
        let namesList = []; 
        let pairingHistory = [];
        let usedPairs = new Set(); // Stores normalized string representation of pairs: "NameA-NameB" (sorted by name)

        // Colors for person icons
        const iconColors = [
            'bg-red-300 text-red-800', 'bg-yellow-300 text-yellow-800', 'bg-green-300 text-green-800',
            'bg-blue-300 text-blue-800', 'bg-indigo-300 text-indigo-800', 'bg-purple-300 text-purple-800',
            'bg-pink-300 text-pink-800', 'bg-orange-300 text-orange-800', 'bg-cyan-300 text-cyan-800',
            'bg-lime-300 text-lime-800', 'bg-emerald-300 text-emerald-800', 'bg-fuchsia-300 text-fuchsia-800'
        ];
        let colorIndex = 0;
        const nameToColorMap = new Map(); // Stores name -> colorClass

        function getPersonColor(name) {
            if (!nameToColorMap.has(name)) {
                nameToColorMap.set(name, iconColors[colorIndex % iconColors.length]);
                colorIndex++;
            }
            return nameToColorMap.get(name);
        }

        // --- LocalStorage Functions ---
        function saveState() {
            localStorage.setItem('namesList_v2', JSON.stringify(namesList)); // Changed key for new structure
            localStorage.setItem('pairingHistory_v2', JSON.stringify(pairingHistory));
            localStorage.setItem('usedPairs_v2', JSON.stringify(Array.from(usedPairs)));
            localStorage.setItem('nameToColorMap_v2', JSON.stringify(Array.from(nameToColorMap.entries())));
        }

        function loadState() {
            const storedNames = localStorage.getItem('namesList_v2');
            if (storedNames) {
                namesList = JSON.parse(storedNames).map(item => ({
                    ...item,
                    // Ensure 'present' defaults to true if migrating from an older version without it
                    present: typeof item.present === 'boolean' ? item.present : true, 
                    // Ensure 'id' exists
                    id: item.id || crypto.randomUUID() 
                }));
            }

            const storedHistory = localStorage.getItem('pairingHistory_v2');
            if (storedHistory) pairingHistory = JSON.parse(storedHistory);

            const storedUsedPairs = localStorage.getItem('usedPairs_v2');
            if (storedUsedPairs) usedPairs = new Set(JSON.parse(storedUsedPairs));
            
            const storedColorMap = localStorage.getItem('nameToColorMap_v2');
            if (storedColorMap) {
                const parsedMap = JSON.parse(storedColorMap);
                parsedMap.forEach(([name, color]) => nameToColorMap.set(name, color));
                colorIndex = nameToColorMap.size;
            }
        }

        // --- UI Rendering Functions ---
        function renderNamesList() {
            namesDisplayList.innerHTML = ''; 
            nameCount.textContent = namesList.length;

            if (namesList.length === 0) {
                emptyNameListMessage.classList.remove('hidden');
            } else {
                emptyNameListMessage.classList.add('hidden');
                namesList.forEach(person => {
                    const li = document.createElement('li');
                    li.className = `name-item bg-white hover:bg-slate-100 rounded-md px-3 py-2 text-slate-700 text-sm ${!person.present ? 'absent' : ''}`;
                    li.dataset.personId = person.id;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = person.name;
                    nameSpan.className = 'name-text truncate max-w-[50%] sm:max-w-[60%]';

                    const buttonsDiv = document.createElement('div');
                    buttonsDiv.className = 'action-buttons flex items-center';

                    const attendanceBtn = document.createElement('button');
                    attendanceBtn.textContent = person.present ? 'ç¼ºå¸­' : 'å‡ºå¸­';
                    attendanceBtn.className = `text-xs font-semibold py-1 px-2 rounded-md shadow-sm ${person.present ? 'bg-yellow-400 hover:bg-yellow-500 text-yellow-800' : 'bg-green-400 hover:bg-green-500 text-green-800'}`;
                    attendanceBtn.addEventListener('click', () => toggleAttendance(person.id));
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'ç§»é™¤';
                    removeBtn.className = 'remove-name-btn text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-2 rounded-md shadow-sm';
                    removeBtn.addEventListener('click', () => removePerson(person.id));
                    
                    buttonsDiv.appendChild(attendanceBtn);
                    buttonsDiv.appendChild(removeBtn);
                    
                    li.appendChild(nameSpan);
                    li.appendChild(buttonsDiv);
                    namesDisplayList.appendChild(li);
                });
            }
        }
        
        function createPersonIconElement(name) {
            const icon = document.createElement('span');
            icon.className = `person-icon ${getPersonColor(name)}`;
            icon.textContent = name;
            return icon;
        }

        function renderCurrentPairing(pairsArray, dateStr) {
            pairsContainer.innerHTML = '';
            noPairingMessage.classList.add('hidden');
            pairingDate.textContent = dateStr;

            if (!pairsArray || pairsArray.length === 0) {
                pairingDate.textContent = '---';
                noPairingMessage.classList.remove('hidden');
                noPairingMessage.textContent = 'æ²’æœ‰è¶³å¤ çš„å‡ºå¸­äººå“¡é€²è¡Œé…å°ï¼Œæˆ–æ²’æœ‰é…å°ç”¢ç”Ÿã€‚';
                return;
            }

            pairsArray.forEach(pair => { // pair is an array of names
                const pairDiv = document.createElement('div');
                pairDiv.className = 'pair flex items-center justify-center my-2 p-2 bg-slate-100 rounded-lg shadow';
                
                pair.forEach((personName, index) => {
                    pairDiv.appendChild(createPersonIconElement(personName));
                    if (index < pair.length - 1) {
                        const connector = document.createElement('span');
                        connector.className = 'pair-connector';
                        connector.innerHTML = '&harr;';
                        pairDiv.appendChild(connector);
                    }
                });
                pairsContainer.appendChild(pairDiv);
            });
        }

        function renderPairingHistory() {
            historyList.innerHTML = '';
            if (pairingHistory.length === 0) {
                noHistoryMessage.classList.remove('hidden');
            } else {
                noHistoryMessage.classList.add('hidden');
                [...pairingHistory].reverse().forEach(record => {
                    const li = document.createElement('li');
                    li.className = 'p-3 bg-slate-100 rounded-md shadow-sm';
                    
                    const dateStrong = document.createElement('strong');
                    dateStrong.className = 'block text-sm text-slate-600 mb-1';
                    dateStrong.textContent = `æ—¥æœŸï¼š${record.date}`;
                    li.appendChild(dateStrong);

                    const pairsDiv = document.createElement('div');
                    pairsDiv.className = 'space-y-1';
                    record.pairs.forEach(pair => { // pair is an array of names
                        const pairP = document.createElement('p');
                        pairP.className = 'text-xs text-slate-700 flex items-center justify-start flex-wrap';
                        pair.forEach((name, index) => {
                            const nameSpan = document.createElement('span');
                            nameSpan.textContent = name;
                            nameSpan.className = `inline-block px-2 py-0.5 rounded-full text-xs mr-1 mb-1 ${getPersonColor(name)}`;
                            pairP.appendChild(nameSpan);
                            if (index < pair.length - 1) {
                                const sep = document.createElement('span');
                                sep.textContent = '-';
                                sep.className = 'mx-1';
                                pairP.appendChild(sep);
                            }
                        });
                        pairsDiv.appendChild(pairP);
                    });
                    li.appendChild(pairsDiv);
                    historyList.appendChild(li);
                });
            }
        }
        
        function showMessage(text, isError = false, duration = 3000) {
            messageArea.textContent = text;
            messageArea.className = `mt-6 text-center text-sm font-medium h-5 ${isError ? 'text-red-600' : 'text-green-600'}`;
            setTimeout(() => {
                messageArea.textContent = '';
                messageArea.className = 'mt-6 text-center text-sm text-red-600 font-medium h-5';
            }, duration);
        }

        // --- Core Logic Functions ---
        function addPerson(name) {
            const trimmedName = name.trim();
            if (trimmedName === '') {
                showMessage('äººåä¸èƒ½ç‚ºç©ºï¼', true);
                return false;
            }
            if (namesList.some(person => person.name === trimmedName)) {
                showMessage(`äººå "${trimmedName}" å·²å­˜åœ¨ï¼`, true);
                return false;
            }
            const newPerson = { id: crypto.randomUUID(), name: trimmedName, present: true };
            namesList.push(newPerson);
            getPersonColor(trimmedName); // Assign color
            return true;
        }

        function handleAddSingleName() {
            const nameValue = singleNameInput.value;
            if (addPerson(nameValue)) {
                showMessage(`å·²æ–°å¢ "${nameValue.trim()}"`, false);
                singleNameInput.value = '';
                renderNamesList();
                saveState();
            }
        }

        function handleAddBatchNames() {
            const batchNamesText = batchNameInput.value;
            const batchNamesArray = batchNamesText.split('\n')
                .map(name => name.trim())
                .filter(name => name !== '');
            
            if (batchNamesArray.length === 0) {
                showMessage('æ‰¹æ¬¡è¼¸å…¥å…§å®¹ç‚ºç©ºï¼', true);
                return;
            }

            let addedCount = 0;
            batchNamesArray.forEach(name => {
                if (addPerson(name)) {
                    addedCount++;
                }
            });

            if (addedCount > 0) {
                showMessage(`æˆåŠŸæ–°å¢ ${addedCount} å€‹äººåã€‚`, false);
                batchNameInput.value = '';
                renderNamesList();
                saveState();
            } else {
                 showMessage('æ‰¹æ¬¡æ–°å¢å¤±æ•—ï¼Œå¯èƒ½äººåéƒ½å·²å­˜åœ¨æˆ–ç‚ºç©ºã€‚', true);
            }
        }
        
        function toggleAttendance(personId) {
            const person = namesList.find(p => p.id === personId);
            if (person) {
                person.present = !person.present;
                showMessage(`${person.name} å·²æ¨™è¨˜ç‚º ${person.present ? 'å‡ºå¸­' : 'ç¼ºå¸­'}`, false);
                renderNamesList();
                saveState();
            }
        }

        function removePerson(personIdToRemove) {
            const personToRemove = namesList.find(p => p.id === personIdToRemove);
            if (!personToRemove) return;

            namesList = namesList.filter(person => person.id !== personIdToRemove);
            // Consider if `usedPairs` or `pairingHistory` should be cleaned up if a person is removed.
            // For now, they are not, as per original logic.
            // nameToColorMap.delete(personToRemove.name); // Optionally remove color mapping
            showMessage(`å·²ç§»é™¤ "${personToRemove.name}"`, false);
            renderNamesList();
            saveState();
        }

        function getNormalizedPair(name1, name2) {
            return [name1, name2].sort().join('-');
        }
        
        function startPairing() {
            const presentParticipants = namesList.filter(person => person.present);
            const presentParticipantNames = presentParticipants.map(p => p.name);

            if (presentParticipantNames.length < 2) {
                showMessage('è‡³å°‘éœ€è¦å…©ä½å‡ºå¸­è€…æ‰èƒ½é–‹å§‹é…å°ï¼', true);
                renderCurrentPairing([], new Date().toLocaleDateString('zh-TW'));
                return;
            }

            let availableNames = [...presentParticipantNames].sort(() => 0.5 - Math.random()); // Shuffle names
            const currentBatchPairs = []; // Stores arrays of names
            
            // Check if all possible unique 2-person pairs *among present participants* have been used
            // This check might need refinement if the set of present people changes often.
            // For now, `usedPairs` stores all historical pairs regardless of current attendance.
            // If all combinations among *currently present* people are used, then reset for *those* people.
            // This is complex. A simpler approach: `usedPairs` tracks all pairs ever made.
            // If `usedPairs` contains all possible pairs from the *current pool of present people*, then reset.
            
            const totalPossibleUniquePairsAmongPresent = presentParticipantNames.length * (presentParticipantNames.length - 1) / 2;
            
            // Count how many of the currently possible pairs are already in usedPairs
            let usedPairsCountAmongPresent = 0;
            if (presentParticipantNames.length >=2) {
                for (let i = 0; i < presentParticipantNames.length; i++) {
                    for (let j = i + 1; j < presentParticipantNames.length; j++) {
                        if (usedPairs.has(getNormalizedPair(presentParticipantNames[i], presentParticipantNames[j]))) {
                            usedPairsCountAmongPresent++;
                        }
                    }
                }
            }

            if (totalPossibleUniquePairsAmongPresent > 0 && usedPairsCountAmongPresent >= totalPossibleUniquePairsAmongPresent) {
                // Clear only those pairs from usedPairs that involve *only* currently present people
                // This is tricky. A simpler global reset might be more manageable:
                // if (usedPairs.size >= totalPossibleUniquePairsAmongAllNames) { usedPairs.clear(); }
                // For now, let's use the simpler original logic: if *all* pairs from *all* names are used, reset all.
                // The user request was "until allçµ„åˆå¯èƒ½éƒ½ç”¨ç›¡ç‚ºæ­¢" - this implies all combinations of the *full list*.
                // However, with attendance, this becomes tricky. Let's stick to the spirit: try to make new pairs.
                // If all possible pairs for the *current attendees* are exhausted, we might need to allow repeats for them.
                // For now, the global `usedPairs` will prevent repeats across all time.
                // If this leads to no new pairs for current attendees, that's a consequence.
            }


            const tempUnavailableInThisRound = new Set(); 

            while (availableNames.length >= 2) {
                const person1Name = availableNames.find(name => !tempUnavailableInThisRound.has(name));
                if (!person1Name) break; 

                availableNames = availableNames.filter(name => name !== person1Name);
                tempUnavailableInThisRound.add(person1Name);

                let person2Name = null;
                let potentialPartners = availableNames.filter(name => !tempUnavailableInThisRound.has(name));
                potentialPartners.sort(() => 0.5 - Math.random()); 

                for (const candidateName of potentialPartners) {
                    const normalizedPair = getNormalizedPair(person1Name, candidateName);
                    if (!usedPairs.has(normalizedPair)) {
                        person2Name = candidateName;
                        break;
                    }
                }

                if (!person2Name && potentialPartners.length > 0) {
                    person2Name = potentialPartners[0]; // Pick randomly if all form used pairs
                }
                
                if (person2Name) {
                    availableNames = availableNames.filter(name => name !== person2Name);
                    tempUnavailableInThisRound.add(person2Name);
                    currentBatchPairs.push([person1Name, person2Name]);
                    usedPairs.add(getNormalizedPair(person1Name, person2Name));
                } else {
                    // If person1Name couldn't find a partner, add back to availableNames if not already handled
                    if (!tempUnavailableInThisRound.has(person1Name) && !currentBatchPairs.flat().includes(person1Name)) {
                         availableNames.push(person1Name);
                    }
                }
            }
            
            // Handle odd number of participants (from the initially available names for this round)
            const remainingNamesInRound = presentParticipantNames.filter(name => !tempUnavailableInThisRound.has(name));

            if (remainingNamesInRound.length === 1 && currentBatchPairs.length > 0) {
                const lastPersonName = remainingNamesInRound[0];
                currentBatchPairs[currentBatchPairs.length - 1].push(lastPersonName);
                tempUnavailableInThisRound.add(lastPersonName); 
            } else if (remainingNamesInRound.length === 1 && currentBatchPairs.length === 0) {
                 currentBatchPairs.push([remainingNamesInRound[0]]); 
            }


            const today = new Date().toLocaleDateString('zh-TW', { year: 'numeric', month: '2-digit', day: '2-digit' });
            if (currentBatchPairs.length > 0) {
                 pairingHistory.push({ date: today, pairs: currentBatchPairs });
                 showMessage('é…å°æˆåŠŸï¼', false);
            } else if (presentParticipantNames.length > 0) { // Had attendees, but no pairs formed
                 showMessage('ç„¡æ³•ç”¢ç”Ÿæ–°çš„é…å°ã€‚å¯èƒ½æ‰€æœ‰å‡ºå¸­è€…çš„çµ„åˆéƒ½å·²é…å°éã€‚', true);
            }


            renderCurrentPairing(currentBatchPairs, today);
            renderPairingHistory();
            saveState();
        }


        function resetRecords() {
            // Use window.confirm for simplicity, as custom modals are more complex
            if (window.confirm('ç¢ºå®šè¦é‡ç½®æ‰€æœ‰é…å°ç´€éŒ„å—ï¼Ÿäººåæ¸…å–®èˆ‡å‡ºå¸­ç‹€æ…‹å°‡æœƒä¿ç•™ã€‚')) {
                pairingHistory = [];
                usedPairs.clear();
                
                renderCurrentPairing([], new Date().toLocaleDateString('zh-TW')); 
                pairingDate.textContent = '---';
                noPairingMessage.classList.remove('hidden');
                noPairingMessage.textContent = 'é»æ“Šã€Œé–‹å§‹é…å°ã€ä¾†æŸ¥çœ‹çµæœï¼';

                renderPairingHistory();
                saveState();
                showMessage('æ‰€æœ‰é…å°ç´€éŒ„å·²é‡ç½®ã€‚', false);
            }
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            renderNamesList();
            renderPairingHistory();
            
            if (pairingHistory.length > 0) {
                const lastPairing = pairingHistory[pairingHistory.length - 1];
                renderCurrentPairing(lastPairing.pairs, lastPairing.date);
            } else {
                pairingDate.textContent = '---';
                noPairingMessage.classList.remove('hidden');
            }

            addSingleNameBtn.addEventListener('click', handleAddSingleName);
            singleNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleAddSingleName();
            });
            addBatchNameBtn.addEventListener('click', handleAddBatchNames);
            startPairingBtn.addEventListener('click', startPairing);
            resetRecordsBtn.addEventListener('click', resetRecords);
        });

    </script>
</body>
</html>
